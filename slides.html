<!doctype html>
<html>

<head>
	<meta charset="utf-8">

	<title>Dissection de async/await</title>

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="reveal.js/dist/reset.css">
	<link rel="stylesheet" href="reveal.js/dist/reveal.css">
	<link rel="stylesheet" href="reveal.js/dist/theme/black.css" id="theme">
	<link rel="stylesheet" href="reveal.js/plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background-image="img/sponsors.png">[INSERT SPONSORS HERE]</section>
			<section data-markdown>
				<textarea data-template>
					## Dissection de async/await

					_Philippe Vlérick_

					![Worldline](img/worldline.png)
				</textarea data-template>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Introduction

						Note:
						Qui utilise asyc/await quotidiennement?
						Qui a déjà écit du code asynchrone sans async/await?
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Le code asynchrone c'est...
						- difficile à écrire <!-- .element: class="fragment" -->
						- difficile à lire <!-- .element: class="fragment" -->
						- souvent incorrect <!-- .element: class="fragment" -->
						- ne parlons même pas des exceptions <!-- .element: class="fragment" -->
						- ...bref, pénible :-) <!-- .element: class="fragment" -->
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### <code>async/await</code>
						- tente de palier à ces problèmes <!-- .element: class="fragment" -->
						- permet d'écrire du code plus expressif <!-- .element: class="fragment" -->

						Note:
						Async/await tente d'apporter une solution afin de permettre l'écriture de code exprimant une intention claire
					</textarea>
				</section>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Démo - Mise en place
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Observations
						- <!-- .element: class="fragment" --> Pas de <code>callback</code> ou d'<code>event</code> 
						- <!-- .element: class="fragment" --> Structure de code familière 
						- <!-- .element: class="fragment" --> Suspend l'execution du code en attendant la fin d'une opération
						  - <!-- .element: class="fragment" --> Sans bloquer le <code>thread</code> ?!
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Points d'attention
						- <!-- .element: class="fragment" --> <code>GetStringAsync</code> renvoie une <code>Task</code>&lt;<code>string</code>&gt;
						- <!-- .element: class="fragment" --> <code>Call Stack</code> après le premier <code>await</code>
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						### <code>Task</code>
						<pre>
							<code data-trim data-noescape>
								// je fais un appel asychrone
								Task<string> t = client.GetStringAsync($"http://localhost:8080");
								// je peux faire autre chose ici
								...
								// je ne peux pas aller plus loin sans le résultat
								string quote = await t;
							</code>
						</pre>
					</textarea data-template>
				</section>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## BlaBla
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Exemple
						[NLog/FilteringTargetWrapper](https://github.com/NLog/NLog/blob/master/src/NLog/Targets/Wrappers/FilteringTargetWrapper.cs)
						<pre>
							<code data-trim data-noescape>
								public abstract class WrapperTargetBase : Target
								{
									public Target WrappedTarget { get; set; }
								}

								public class FilteringTargetWrapper : WrapperTargetBase
								{
									public FilteringTargetWrapper(Target wrappedTarget,
										ConditionExpression condition)
									{
										WrappedTarget = wrappedTarget;
										Condition = condition;
									}
								}
							</code>
						</pre>
					</textarea data-template>
				</section>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Conclusions
					</textarea>
				</section>
			</section>
		</div>
	</div>

	<script src="reveal.js/dist/reveal.js"></script>
	<script src="reveal.js/plugin/zoom/zoom.js"></script>
	<script src="reveal.js/plugin/notes/notes.js"></script>
	<script src="reveal.js/plugin/search/search.js"></script>
	<script src="reveal.js/plugin/markdown/markdown.js"></script>
	<script src="reveal.js/plugin/highlight/highlight.js"></script>
	<script>

		// Also available as an ES module, see:
		// https://revealjs.com/initialization/
		Reveal.initialize({
			controls: true,
			progress: true,
			center: true,
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
		});

	</script>
</body>

</html>