<!doctype html>
<html>

<head>
	<meta charset="utf-8">

	<title>Dissection de async/await</title>

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="reveal.js/css/reveal.css">
	<link rel="stylesheet" href="reveal.js/css/theme/night.css">
	<link rel="stylesheet" href="reveal.js/lib/css/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background-image="img/sponsors.png">[INSERT SPONSORS HERE]</section>
			<section data-markdown>
				<textarea data-template>
					## Dissection de async/await

					_Philippe Vlérick_

					![Worldline](img/worldline.png)
				</textarea data-template>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Introduction

						Note:
						Qui utilise asyc/await quotidiennement?
						Qui a déjà écit du code asynchrone sans async/await?
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Le code asynchrone c'est...
						- difficile à écrire <!-- .element: class="fragment" -->
						- difficile à lire <!-- .element: class="fragment" -->
						- souvent incorrect <!-- .element: class="fragment" -->
						- ne parlons même pas des exceptions <!-- .element: class="fragment" -->
						- ... pénible <!-- .element: class="fragment" -->
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### <code>async</code>/<code>await</code>
						- tente de palier à ces problèmes <!-- .element: class="fragment" -->
						- permet du code plus familier <!-- .element: class="fragment" -->
						

						Note:
						Async/await tente d'apporter une solution afin de permettre l'écriture de code exprimant une intention claire
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Que va-t-on faire?
						- Écrire un peu de code <!-- .element: class="fragment" -->
						- Regarder sous le capot <!-- .element: class="fragment" -->

						Note:
						Bonne question!
					</textarea>
				</section>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Démo 1
						#### Mise en place
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Observations
						- <!-- .element: class="fragment" --> pas de <code>callback</code> ou d'<code>event</code> 
						- <!-- .element: class="fragment" --> structure de code familière 
						  - <!-- .element: class="fragment" --> ressemble a du code bloquant
						  
						Note:
						Le code ressemble à du code bloquant, le seul gain est dans la performance
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Points d'attention
						- <!-- .element: class="fragment" --> <code>GetStringAsync</code> renvoie une <code>Task</code>&lt;<code>string</code>&gt;
						![Task](img/task.png)
						  - <!-- .element: class="fragment" --> une future <code>string</code>
						- <!-- .element: class="fragment" --> <code>Call Stack</code> après le premier <code>await</code>
						![Call Stack](img/callstack.png)
						  - <!-- .element: class="fragment" --> il y a bien eu un callback (ou continuation)
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						## Démo 2
						#### Découpe entre appel et <code>await</code>
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Observations
						- <!-- .element: class="fragment" --> appel à <code>GetStringAsync</code> découplé de l'attente du résultat
						- <!-- .element: class="fragment" --> <code>await</code> suspend l'execution du code en attendant la fin d'une opération
						  - <!-- .element: class="fragment" --> sans bloquer le <code>thread</code>
						  
						Note:
						await est équivalent à dire "j'ai été aussi loin que le pouvais, à présent j'ai besoin du résultat pour continuer" 
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						![Await](img/await.png)

						Note:
						Si la Task est deja terminée, l'execution sera synchrone
						Retour à l'appelant != methode execution terminée!
					</textarea data-template>
				</section>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Conclusions
					</textarea>
				</section>
			</section>
		</div>
	</div>

	<script src="reveal.js/lib/js/head.min.js"></script>
	<script src="reveal.js/js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [
				{ src: 'reveal.js/plugin/markdown/marked.js' },
				{ src: 'reveal.js/plugin/markdown/markdown.js' },
				{ src: 'reveal.js/plugin/notes/notes.js', async: true },
				{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>