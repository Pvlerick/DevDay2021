<!doctype html>
<html>

<head>
	<meta charset="utf-8">

	<title>Dissection de async/await</title>

	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="stylesheet" href="reveal.js/css/reveal.css">
	<link rel="stylesheet" href="reveal.js/css/theme/night.css">
	<link rel="stylesheet" href="reveal.js/lib/css/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-background-image="img/sponsors.png">[INSERT SPONSORS HERE]</section>
			<section data-markdown>
				<textarea data-template>
					## Dissection de async/await

					_Philippe Vlérick_

					![Worldline](img/worldline.png)
				</textarea data-template>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Introduction

						Note:
						Qui utilise asyc/await quotidiennement?
						Qui a déjà écit du code asynchrone sans async/await?
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Le code asynchrone c'est...
						- difficile à écrire <!-- .element: class="fragment" -->
						- difficile à lire <!-- .element: class="fragment" -->
						- souvent incorrect <!-- .element: class="fragment" -->
						- ne parlons même pas des exceptions <!-- .element: class="fragment" -->
						- ...bref, pénible :-) <!-- .element: class="fragment" -->
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### <code>async/await</code>
						- tente de palier à ces problèmes <!-- .element: class="fragment" -->
						- permet d'écrire du code plus expressif <!-- .element: class="fragment" -->

						Note:
						Async/await tente d'apporter une solution afin de permettre l'écriture de code exprimant une intention claire
					</textarea>
				</section>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Démo - Mise en place
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Observations
						- <!-- .element: class="fragment" --> Pas de <code>callback</code> ou d'<code>event</code> 
						- <!-- .element: class="fragment" --> Structure de code familière 
						- <!-- .element: class="fragment" --> Suspend l'execution du code en attendant la fin d'une opération
						  - <!-- .element: class="fragment" --> Sans bloquer le <code>thread</code> ?!
					</textarea>
				</section>
				<section data-markdown>
					<textarea data-template>
						### Points d'attention
						- <!-- .element: class="fragment" --> <code>GetStringAsync</code> renvoie une <code>Task</code>&lt;<code>string</code>&gt;
						![Worldline](img/task.png)
						- <!-- .element: class="fragment" --> <code>Call Stack</code> après le premier <code>await</code>
						![Worldline](img/callstack.png)
					</textarea data-template>
				</section>
				<section data-markdown>
					<textarea data-template>
						### <code>Task</code>
						<pre>
							<code data-trim data-noescape>
								// je fais un appel asychrone
								Task<string> t = client.GetStringAsync($"http://localhost:8080");
								// je peux faire autre chose ici
								...
								// je ne peux pas aller plus loin sans le résultat
								string quote = await t;
							</code>
						</pre>
					</textarea data-template>
				</section>
			</section>
			<section>
				<section data-markdown>
					<textarea data-template>
						## Conclusions
					</textarea>
				</section>
			</section>
		</div>
	</div>

	<script src="reveal.js/lib/js/head.min.js"></script>
	<script src="reveal.js/js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [
				{ src: 'reveal.js/plugin/markdown/marked.js' },
				{ src: 'reveal.js/plugin/markdown/markdown.js' },
				{ src: 'reveal.js/plugin/notes/notes.js', async: true },
				{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>